<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C.E.N.T.A.U.R — 3D Top-Down</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#0d0d0d; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; font-family:'Courier New', monospace; }
  #title { color:#e0e0e0; font-size:0.75rem; letter-spacing:0.35em; margin-bottom:8px; text-transform:uppercase; opacity:0.7; }
  canvas { display:block; }
  #phase-label { color:#fff; font-size:0.65rem; letter-spacing:0.18em; margin-top:6px; min-height:1em; opacity:0.85; }
  #hud { display:flex; gap:28px; margin-top:6px; color:#aaa; font-size:0.6rem; letter-spacing:0.12em; }
</style>
</head>
<body>
<div id="title">C · E · N · T · A · U · R &nbsp;|&nbsp; OBSTACLE NAVIGATION SIM</div>
<canvas id="c" width="720" height="540"></canvas>
<div id="phase-label">[ INITIALIZING ]</div>
<div id="hud">
  <span id="h1">THREAT: —</span>
  <span id="h2">PATH: —</span>
  <span id="h3">STATE: —</span>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const TILE = 52, COLS = 8, ROWS = 8;
const ORIG_X = W/2, ORIG_Y = 80, WALL_H = 55;

function isoX(c,r){ return ORIG_X+(c-r)*TILE; }
function isoY(c,r){ return ORIG_Y+(c+r)*(TILE*0.5); }
function tc(c,r){ return {x:isoX(c,r), y:isoY(c,r)+TILE*0.25}; }
function lerp(a,b,t){ return a+(b-a)*t; }
function eio(x){ return x<0.5?2*x*x:1-Math.pow(-2*x+2,2)/2; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// ─────────────────────────────────────────────
// PHASES:
//  0 = SCAN        bot idle at (1,4), planning
//  1 = APPROACH    bot walks full path to beside stickman (5,6)
//  2 = ENCOUNTER   bot pauses beside stickman — barrel explodes, stickman dies
//  3 = EXIT        bot walks from (5,6) → (7,4) through door
//  4 = DONE        brief pause then reset
// ─────────────────────────────────────────────
// Phase durations in frames
const DUR = [100, 260, 90, 140, 80];

// Phase 1 path: (1,4) → (5,6)  [the approach, passing barrel side, reaching stickman]
const PATH_APPROACH = [[1,4],[2,4],[3,4],[3,5],[3,6],[4,6],[5,6]];

// Phase 3 path: (5,6) → exit door at (8,4)
const PATH_EXIT = [[5,6],[6,5],[7,4]];

// Full display path for ghost
const PATH_FULL = [[1,4],[2,4],[3,4],[3,5],[3,6],[4,6],[5,6],[6,5],[7,4]];

let t=0, phase=0, pTimer=0;
let botX=0, botY=0;

// Bullets
let bullets=[], bulletHoles=[], nextShot=30;

// Explosion
let expl=null;

// Stickman
let stkDead=false, stkAngle=0;

// Barrel
let barrelGone=false;

// Scan rings
let scanRings=[];

// ─────────────────────────────────────────────
function pFrac(){ return clamp(pTimer/DUR[phase], 0, 1); }

function getBotPos(){
  let f = eio(pFrac());
  if(phase===0){
    return tc(1,4);
  }
  if(phase===1){
    let seg=PATH_APPROACH, n=seg.length-1;
    let cf=f*n, si=clamp(Math.floor(cf),0,n-1), sf=cf-si;
    let p0=tc(...seg[si]), p1=tc(...seg[Math.min(si+1,n)]);
    return {x:lerp(p0.x,p1.x,eio(sf)), y:lerp(p0.y,p1.y,eio(sf))};
  }
  if(phase===2){
    return tc(5,6); // standing beside stickman
  }
  if(phase>=3){
    let seg=PATH_EXIT, n=seg.length-1;
    let cf=f*n, si=clamp(Math.floor(cf),0,n-1), sf=cf-si;
    let p0=tc(...seg[si]), p1=tc(...seg[Math.min(si+1,n)]);
    return {x:lerp(p0.x,p1.x,eio(sf)), y:lerp(p0.y,p1.y,eio(sf))};
  }
  return tc(1,4);
}

function overallProgress(){
  if(phase===0) return 0;
  if(phase===1) return pFrac() * 0.72;
  if(phase===2) return 0.72;
  if(phase===3) return 0.72 + pFrac()*0.28;
  return 1;
}

// ─────────────────────────────────────────────
function updatePhase(){
  pTimer++;

  // PHASE 1: stickman fires at bot while it approaches
  if(phase===1 && !barrelGone){
    nextShot--;
    if(nextShot<=0){
      let pos=getBotPos();
      // Near-miss shots — aimed close to bot
      spawnBullet(pos.x+(Math.random()-0.5)*50, pos.y+(Math.random()-0.5)*25, false);
      // Drop holes
      bulletHoles.push({x:pos.x+(Math.random()-0.5)*70, y:pos.y+(Math.random()-0.5)*35, a:Math.random()*Math.PI*2});
      nextShot = 20+Math.floor(Math.random()*18);
    }
  }

  // PHASE 2: bot beside stickman → explosion happens at frame 25
  if(phase===2){
    if(pTimer===25 && !barrelGone){
      let bp=tc(1,5);
      // One bullet from stickman flies toward barrel
      spawnBulletFromStickman(bp.x, bp.y-18);
    }
    // Force explosion at frame 45 regardless
    if(pTimer===45 && !barrelGone){
      let bp=tc(1,5);
      triggerExplosion(bp.x, bp.y-16);
    }
  }

  updateBullets();
  if(expl){ expl.age++; expl.parts.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vx*=0.92; p.vy*=0.92; p.life-=0.013; p.rot+=p.rv; }); expl.parts=expl.parts.filter(p=>p.life>0); }
  if(stkDead && stkAngle<Math.PI/2) stkAngle+=0.055;

  // Advance phase
  if(pTimer >= DUR[phase]){
    pTimer=0;
    if(phase===4){
      // RESET
      phase=0; bullets=[]; bulletHoles=[]; expl=null;
      stkDead=false; stkAngle=0; barrelGone=false; scanRings=[]; nextShot=30;
    } else {
      phase++;
    }
  }
}

// ─────────────────────────────────────────────
// BULLETS
// ─────────────────────────────────────────────
function spawnBullet(tx,ty,isBarrel){
  let src=tc(6,6);
  let sx=src.x, sy=src.y-28;
  let dx=tx-sx, dy=ty-sy, d=Math.sqrt(dx*dx+dy*dy)||1;
  bullets.push({x:sx, y:sy, vx:dx/d*11, vy:dy/d*11, trail:[], isBarrel, life:1});
}

function spawnBulletFromStickman(tx,ty){
  let src=tc(6,6);
  let sx=src.x, sy=src.y-28;
  let dx=tx-sx, dy=ty-sy, d=Math.sqrt(dx*dx+dy*dy)||1;
  // Slower for visibility
  bullets.push({x:sx, y:sy, vx:dx/d*7, vy:dy/d*7, trail:[], isBarrel:true, life:1.5});
}

function updateBullets(){
  bullets.forEach(b=>{
    b.trail.push({x:b.x, y:b.y});
    if(b.trail.length>14) b.trail.shift();
    b.x+=b.vx; b.y+=b.vy; b.life-=0.018;
    if(!b.isBarrel && b.life<0.22 && Math.random()<0.3){
      bulletHoles.push({x:b.x+(Math.random()*8-4), y:b.y+(Math.random()*5-2.5), a:Math.random()*Math.PI*2});
    }
  });
  bullets=bullets.filter(b=>b.life>0);
}

function drawBullets(){
  bullets.forEach(b=>{
    b.trail.forEach((p,i)=>{
      ctx.globalAlpha=(i/b.trail.length)*0.55;
      ctx.fillStyle=b.isBarrel?'#fff':'#ccc';
      ctx.beginPath(); ctx.arc(p.x,p.y,1.3,0,Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha=1;
    let ang=Math.atan2(b.vy,b.vx);
    ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(ang);
    ctx.fillStyle='#fff'; ctx.strokeStyle='#777'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.ellipse(0,0,4,1.5,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.restore();
  });
  ctx.globalAlpha=1;
}

// ─────────────────────────────────────────────
// EXPLOSION
// ─────────────────────────────────────────────
function triggerExplosion(ex,ey){
  if(barrelGone) return;
  barrelGone=true; stkDead=true;
  let parts=[];
  for(let i=0;i<80;i++){
    let a=Math.random()*Math.PI*2, sp=Math.random()*9+2;
    parts.push({x:ex,y:ey,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,
      life:1+Math.random()*0.4, sz:Math.random()*7+2,
      rot:Math.random()*Math.PI*2, rv:(Math.random()-0.5)*0.25,
      type:i%3===0?'fire':i%3===1?'smoke':'chunk'});
  }
  for(let i=0;i<12;i++){
    let a=i/12*Math.PI*2;
    bulletHoles.push({x:ex+Math.cos(a)*26, y:ey+Math.sin(a)*15, a});
  }
  expl={x:ex, y:ey, age:0, parts};
}

function drawExplosion(){
  if(!expl) return;
  let age=expl.age;
  // Scorch
  if(age>8){
    let sr=clamp(age*1.4, 0, 58);
    ctx.globalAlpha=0.3; ctx.fillStyle='#060606';
    ctx.beginPath(); ctx.ellipse(expl.x,expl.y,sr,sr*0.58,0,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
  // Shockwave
  if(age<60){
    ctx.globalAlpha=(1-age/60)*0.8; ctx.strokeStyle='#eee'; ctx.lineWidth=2.5;
    ctx.beginPath(); ctx.arc(expl.x,expl.y,age*6,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
  }
  if(age<90){
    ctx.globalAlpha=(1-age/90)*0.3; ctx.strokeStyle='#aaa'; ctx.lineWidth=1; ctx.setLineDash([5,5]);
    ctx.beginPath(); ctx.arc(expl.x,expl.y,age*3.5,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]); ctx.globalAlpha=1;
  }
  // Flash
  if(age<24){
    let r=40*(1-age/24);
    ctx.globalAlpha=(1-age/24)*0.92; ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.arc(expl.x,expl.y,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
  }
  // Particles
  expl.parts.forEach(p=>{
    if(p.life<=0) return;
    ctx.globalAlpha=clamp(p.life,0,1);
    if(p.type==='fire'){
      ctx.fillStyle=p.life>0.55?'#fff':p.life>0.3?'#ccc':'#888';
      ctx.beginPath(); ctx.arc(p.x,p.y,p.sz*clamp(p.life,0,1),0,Math.PI*2); ctx.fill();
    } else if(p.type==='smoke'){
      ctx.fillStyle='#3a3a3a';
      ctx.beginPath(); ctx.arc(p.x,p.y,p.sz*(1.4+0.6*(1-p.life)),0,Math.PI*2); ctx.fill();
    } else {
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.fillStyle='#777'; ctx.strokeStyle='#222'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.rect(-p.sz/2,-p.sz/4,p.sz,p.sz/2); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  });
  ctx.globalAlpha=1;
}

// ─────────────────────────────────────────────
// FLOOR
// ─────────────────────────────────────────────
function drawFloor(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    let x0=isoX(c,r),y0=isoY(c,r),x1=isoX(c+1,r),y1=isoY(c+1,r);
    let x2=isoX(c+1,r+1),y2=isoY(c+1,r+1),x3=isoX(c,r+1),y3=isoY(c,r+1);
    ctx.fillStyle=(c+r)%2===0?'#1a1a1a':'#212121';
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#2e2e2e'; ctx.lineWidth=0.7; ctx.stroke();
    let mx=(x0+x1+x2+x3)/4, my=(y0+y1+y2+y3)/4;
    ctx.font='6px Courier New'; ctx.fillStyle='#272727'; ctx.textAlign='center';
    ctx.fillText(`${c},${r}`,mx,my+2);
  }
}

function drawBulletHoles(){
  bulletHoles.forEach(h=>{
    ctx.save(); ctx.translate(h.x,h.y); ctx.rotate(h.a);
    ctx.fillStyle='#0a0a0a'; ctx.beginPath(); ctx.ellipse(0,0,5,3,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#3a3a3a'; ctx.lineWidth=1; ctx.beginPath(); ctx.ellipse(0,0,5,3,0,0,Math.PI*2); ctx.stroke();
    ctx.strokeStyle='#252525'; ctx.lineWidth=0.5;
    for(let i=0;i<5;i++){let a=i*Math.PI*2/5; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*9,Math.sin(a)*5); ctx.stroke();}
    ctx.restore();
  });
}

// ─────────────────────────────────────────────
// WALLS
// ─────────────────────────────────────────────
function drawWall(c0,r0,c1,r1){
  let ax=isoX(c0,r0),ay=isoY(c0,r0),bx=isoX(c1,r1),by=isoY(c1,r1);
  ctx.fillStyle='#1a1a1a';
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(bx,by+WALL_H); ctx.lineTo(ax,ay+WALL_H);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='#404040'; ctx.lineWidth=1; ctx.stroke();
  ctx.strokeStyle='#505050'; ctx.lineWidth=1.2;
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
}
function drawPillar(c,r){
  let x=isoX(c,r),y=isoY(c,r);
  ctx.fillStyle='#555'; ctx.beginPath(); ctx.arc(x,y+WALL_H/2,4,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#404040'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y+WALL_H); ctx.stroke();
}
function drawDoor(c,r){
  let ax=isoX(c,r),ay=isoY(c,r),bx=isoX(c,r+1),by=isoY(c,r+1);
  // Glow when bot approaching
  if(phase===3 && pFrac()>0.5){
    let ga=(pFrac()-0.5)/0.5;
    ctx.globalAlpha=ga*0.35; ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(bx,by+WALL_H*0.85); ctx.lineTo(ax,ay+WALL_H*0.85); ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1;
  }
  ctx.strokeStyle='#777'; ctx.lineWidth=2.5; ctx.fillStyle='#111';
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(bx,by+WALL_H*0.85); ctx.lineTo(ax,ay+WALL_H*0.85);
  ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.strokeStyle='#555'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(ax+4,ay+4); ctx.lineTo(bx-4,by+4); ctx.lineTo(bx-4,by+WALL_H*0.8); ctx.lineTo(ax+4,ay+WALL_H*0.8); ctx.closePath(); ctx.stroke();
  ctx.fillStyle='#888'; ctx.beginPath(); ctx.arc(ax+12,ay+WALL_H*0.45,2.5,0,Math.PI*2); ctx.fill();
  ctx.font='bold 7px Courier New'; ctx.fillStyle='#777'; ctx.textAlign='center';
  ctx.fillText('EXIT',(ax+bx)/2,ay-4);
}
function drawRoom(){
  for(let c=0;c<COLS;c++) drawWall(c,0,c+1,0);
  for(let r=0;r<ROWS;r++) drawWall(0,r,0,r+1);
  for(let r=0;r<ROWS;r++){ if(r===4) drawDoor(COLS,r); else drawWall(COLS,r,COLS,r+1); }
  for(let c=0;c<COLS;c++) drawWall(c,ROWS,c+1,ROWS);
  drawPillar(0,0); drawPillar(COLS,0); drawPillar(0,ROWS); drawPillar(COLS,ROWS);
}

// ─────────────────────────────────────────────
// PATH DRAWING
// ─────────────────────────────────────────────
function drawPaths(){
  // Ghost full path
  ctx.setLineDash([4,6]); ctx.strokeStyle='#282828'; ctx.lineWidth=1.5;
  ctx.beginPath();
  PATH_FULL.forEach(([c,r],i)=>{let p=tc(c,r); i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y);});
  ctx.stroke(); ctx.setLineDash([]);

  // Travelled portion
  let prog=overallProgress();
  let n=PATH_FULL.length-1;
  let cf=prog*n, si=clamp(Math.floor(cf),0,n-1), sf=cf-si;
  if(prog>0.01){
    ctx.strokeStyle='#888'; ctx.lineWidth=2; ctx.beginPath();
    for(let i=0;i<=si&&i<PATH_FULL.length;i++){let p=tc(...PATH_FULL[i]); i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y);}
    if(si<n){let p0=tc(...PATH_FULL[si]),p1=tc(...PATH_FULL[Math.min(si+1,n)]); ctx.lineTo(lerp(p0.x,p1.x,eio(sf)),lerp(p0.y,p1.y,eio(sf)));}
    ctx.stroke();
  }

  // Waypoint dots
  PATH_FULL.forEach(([c,r],i)=>{
    let p=tc(c,r), vis=(i/n<=prog);
    ctx.fillStyle=vis?'#ccc':'#2e2e2e'; ctx.strokeStyle=vis?'#eee':'#444'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(p.x,p.y,vis?3:2,0,Math.PI*2); ctx.fill(); ctx.stroke();
  });

  // Moving arrow head
  if(prog>0.02&&prog<1){
    let p0=tc(...PATH_FULL[si]), p1=tc(...PATH_FULL[Math.min(si+1,n)]);
    let hx=lerp(p0.x,p1.x,eio(sf)), hy=lerp(p0.y,p1.y,eio(sf));
    let ang=Math.atan2(p1.y-p0.y, p1.x-p0.x);
    ctx.save(); ctx.translate(hx,hy); ctx.rotate(ang);
    ctx.fillStyle='#bbb'; ctx.beginPath(); ctx.moveTo(9,0); ctx.lineTo(-4,4); ctx.lineTo(-4,-4); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

// ─────────────────────────────────────────────
// BARREL
// ─────────────────────────────────────────────
function drawBarrel(){
  if(barrelGone) return;
  let{x,y}=tc(1,5); y-=6;
  let rx=11,rh=28;
  ctx.fillStyle=`rgba(255,60,0,${0.05+0.04*Math.sin(t*0.08)})`;
  ctx.beginPath(); ctx.ellipse(x,y+rh*0.5+2,rx*2.5,10,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(0,0,0,0.45)';
  ctx.beginPath(); ctx.ellipse(x,y+rh*0.5+6,rx+4,5,0,0,Math.PI*2); ctx.fill();
  let bg=ctx.createLinearGradient(x-rx,0,x+rx,0);
  bg.addColorStop(0,'#1a1a1a'); bg.addColorStop(0.4,'#555'); bg.addColorStop(0.8,'#3a3a3a'); bg.addColorStop(1,'#111');
  ctx.fillStyle=bg; ctx.strokeStyle='#666'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.ellipse(x,y-rh*0.5,rx,5,0,Math.PI,0); ctx.rect(x-rx,y-rh*0.5,rx*2,rh); ctx.ellipse(x,y+rh*0.5,rx,5,0,0,Math.PI); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x,y+rh*0.5,rx,5,0,0,Math.PI*2); ctx.stroke();
  [0,0.3,0.7,1].forEach(p=>{ ctx.strokeStyle='#666'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(x,y-rh*0.5+rh*p,rx,4,0,0,Math.PI*2); ctx.stroke(); });
  ctx.fillStyle='#555'; ctx.strokeStyle='#777'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.ellipse(x,y-rh*0.5,rx,5,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle=Math.sin(t*0.15)>0?'#ff3333':'#888'; ctx.font='bold 10px Courier New'; ctx.textAlign='center'; ctx.fillText('!',x,y+3);
  let fh=13+Math.sin(t*0.2)*4+Math.random()*2, fw=6+Math.cos(t*0.15)*1.5;
  ctx.globalAlpha=0.8; ctx.fillStyle='#ff5500'; ctx.beginPath(); ctx.ellipse(x,y-rh*0.5-fh*0.4,fw,fh*0.5,Math.sin(t*0.15)*0.2,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=0.9; ctx.fillStyle='#ffcc00'; ctx.beginPath(); ctx.ellipse(x,y-rh*0.5-fh*0.3,fw*0.6,fh*0.35,0,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=1;
  for(let i=0;i<4;i++){ let el=(t+i*15)%60,ey2=y-rh*0.5-el*0.45,ex2=x+Math.sin((t+i*20)*0.1)*6,ea=1-el/60; ctx.fillStyle=`rgba(255,200,50,${ea})`; ctx.beginPath(); ctx.arc(ex2,ey2,1.2,0,Math.PI*2); ctx.fill(); }
  ctx.font='6px Courier New'; ctx.fillStyle='#555'; ctx.fillText('BARREL',x,y+rh*0.5+16);
}

// ─────────────────────────────────────────────
// STICKMAN
// ─────────────────────────────────────────────
function drawStickman(){
  let{x,y}=tc(6,6); y-=4;
  const hs=10,th=28;

  if(stkDead){
    ctx.save(); ctx.translate(x,y); ctx.rotate(clamp(stkAngle,0,Math.PI/2));
    ctx.strokeStyle='#555'; ctx.lineWidth=2.5; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-th-hs*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,-th*0.3); ctx.lineTo(-14,-th*0.1); ctx.moveTo(0,-th*0.3); ctx.lineTo(14,-th*0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,th*0.3); ctx.moveTo(0,0); ctx.lineTo(10,th*0.3); ctx.stroke();
    ctx.fillStyle='#1a1a1a'; ctx.strokeStyle='#555'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,-th-hs*1.5,hs,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.strokeStyle='#666'; ctx.lineWidth=1.5;
    [[-4,-th-hs*1.6+2],[3,-th-hs*1.6+2]].forEach(([ex,ey])=>{
      ctx.beginPath(); ctx.moveTo(ex-2,ey-2); ctx.lineTo(ex+2,ey+2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex+2,ey-2); ctx.lineTo(ex-2,ey+2); ctx.stroke();
    });
    ctx.restore();
    ctx.font='bold 7px Courier New'; ctx.fillStyle='#555'; ctx.textAlign='center';
    ctx.fillText('K.I.A.',x,y+18);
    return;
  }

  ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(x,y+4,14,5,0,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#bbb'; ctx.lineWidth=2.5; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(x,y-hs-2); ctx.lineTo(x,y-hs-th); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x,y-hs-2); ctx.lineTo(x-10,y+2); ctx.moveTo(x,y-hs-2); ctx.lineTo(x+10,y+2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x,y-hs-th*0.65); ctx.lineTo(x+10,y-hs-th*0.35); ctx.stroke();
  // Arm aiming — fires in phase 1, alarm in phase 2
  let recoil=(phase===1||phase===2)?Math.sin(t*0.38)*0.18:0;
  let aa=-0.3+recoil, al=22;
  let aex=x-Math.cos(aa)*al, aey=y-hs-th*0.7+Math.sin(aa)*al*0.3;
  ctx.beginPath(); ctx.moveTo(x,y-hs-th*0.7); ctx.lineTo(aex,aey); ctx.stroke();
  ctx.fillStyle='#2a2a2a'; ctx.strokeStyle='#bbb'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(x,y-hs-th-hs*0.5,hs,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#f0f0f0'; ctx.beginPath(); ctx.arc(x-3.5,y-hs-th-hs*0.6,1.8,0,Math.PI*2); ctx.arc(x+3.5,y-hs-th-hs*0.6,1.8,0,Math.PI*2); ctx.fill();

  // GUN
  ctx.save(); ctx.translate(aex,aey); ctx.rotate(aa-0.1); ctx.scale(0.7,0.7);
  let rg=ctx.createLinearGradient(-26,0,-26,10); rg.addColorStop(0,'#888'); rg.addColorStop(0.5,'#444'); rg.addColorStop(1,'#222');
  ctx.fillStyle=rg; ctx.strokeStyle='#999'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.roundRect(-26,-4,22,8,2); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#555'; ctx.strokeStyle='#888'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.roundRect(-52,-2.5,28,5,1); ctx.fill(); ctx.stroke();
  ctx.strokeStyle='#777'; ctx.lineWidth=0.6; for(let i=-50;i<-28;i+=5){ ctx.beginPath(); ctx.moveTo(i,-3); ctx.lineTo(i,-1); ctx.stroke(); }
  ctx.fillStyle='#333'; ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.beginPath(); ctx.roundRect(-58,-4,8,8,1); ctx.fill(); ctx.stroke();
  [-56,-53,-50].forEach(mx=>{ ctx.strokeStyle='#222'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.moveTo(mx,-3.5); ctx.lineTo(mx,-1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(mx,1); ctx.lineTo(mx,3.5); ctx.stroke(); });
  ctx.strokeStyle='#777'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.arc(-14,6,5,0,Math.PI); ctx.stroke();
  ctx.strokeStyle='#888'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-14,3); ctx.lineTo(-15,8); ctx.stroke();
  let gg=ctx.createLinearGradient(-8,4,-8,18); gg.addColorStop(0,'#555'); gg.addColorStop(1,'#1a1a1a');
  ctx.fillStyle=gg; ctx.strokeStyle='#777'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.roundRect(-10,3,8,16,[0,0,3,3]); ctx.fill(); ctx.stroke();
  ctx.strokeStyle='#333'; ctx.lineWidth=0.5; for(let gy=6;gy<18;gy+=2.5){ ctx.beginPath(); ctx.moveTo(-10,gy); ctx.lineTo(-3,gy); ctx.stroke(); }
  ctx.fillStyle='#3a3a3a'; ctx.strokeStyle='#666'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.roundRect(-16,3,6,13,[0,0,2,2]); ctx.fill(); ctx.stroke();
  ctx.fillStyle='#777'; ctx.beginPath(); ctx.rect(-24,-7,4,3); ctx.fill(); ctx.fillStyle='#222'; ctx.beginPath(); ctx.rect(-23,-6,2,2); ctx.fill();
  ctx.fillStyle='#777'; ctx.beginPath(); ctx.rect(-48,-7,3,4); ctx.fill();
  // Muzzle flash
  if((phase===1||(phase===2&&pTimer<25))&&Math.sin(t*0.38)>0.5){
    ctx.globalAlpha=0.95; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(-72,0,13,6,0,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=0.6; ctx.fillStyle='#ddd'; ctx.beginPath(); ctx.ellipse(-68,-5,5,2.5,-0.4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(-68,5,5,2.5,0.4,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
  ctx.restore();
  ctx.font='6px Courier New'; ctx.fillStyle='#555'; ctx.textAlign='center'; ctx.fillText('HOSTILE',x,y+12);
}

// ─────────────────────────────────────────────
// BUG BOT
// ─────────────────────────────────────────────
function drawBot(){
  let pos=getBotPos(); botX=pos.x; botY=pos.y;
  let rx=pos.x, ry=pos.y-8;
  const moving=(phase===1||phase===3);
  const lw=moving?t*0.22:t*0.07;

  ctx.save(); ctx.translate(rx,ry);
  let grd=ctx.createRadialGradient(0,0,0,0,0,35);
  grd.addColorStop(0,'rgba(255,255,255,0.06)'); grd.addColorStop(1,'transparent');
  ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(0,0,35,0,Math.PI*2); ctx.fill();

  // Legs
  ctx.strokeStyle='#777'; ctx.lineWidth=1.8; ctx.lineCap='round';
  [[-14,-6,-28,-16+Math.sin(lw)*6,-36,-10+Math.sin(lw)*6],
   [-14,0,-30,Math.sin(lw+1)*5,-38,6+Math.sin(lw+1)*5],
   [-14,6,-26,14+Math.sin(lw+2)*6,-34,18+Math.sin(lw+2)*6],
   [14,-6,28,-16+Math.sin(lw+3)*6,36,-10+Math.sin(lw+3)*6],
   [14,0,30,Math.sin(lw+4)*5,38,6+Math.sin(lw+4)*5],
   [14,6,26,14+Math.sin(lw+5)*6,34,18+Math.sin(lw+5)*6]
  ].forEach(([x1,y1,x2,y2,x3,y3])=>{
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.stroke();
    ctx.fillStyle='#555'; ctx.beginPath(); ctx.arc(x3,y3,2,0,Math.PI*2); ctx.fill();
  });

  // Body
  let bg=ctx.createLinearGradient(-18,-10,18,10);
  bg.addColorStop(0,'#2a2a2a'); bg.addColorStop(0.4,'#555'); bg.addColorStop(0.7,'#3a3a3a'); bg.addColorStop(1,'#1a1a1a');
  ctx.fillStyle=bg; ctx.strokeStyle='#888'; ctx.lineWidth=1.2;
  ctx.beginPath(); ctx.ellipse(0,0,18,11,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.strokeStyle='#444'; ctx.lineWidth=0.8; ctx.beginPath(); ctx.ellipse(0,0,10,7,0,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-18,0); ctx.lineTo(18,0); ctx.stroke();
  ctx.strokeStyle='#333'; [-6,0,6].forEach(lx=>{ ctx.beginPath(); ctx.moveTo(lx,-11); ctx.lineTo(lx,11); ctx.stroke(); });

  // Head
  let hg=ctx.createLinearGradient(14,-8,30,8); hg.addColorStop(0,'#555'); hg.addColorStop(1,'#222');
  ctx.fillStyle=hg; ctx.strokeStyle='#999'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.ellipse(22,0,10,8,0,0,Math.PI*2); ctx.fill(); ctx.stroke();

  // Eyes
  const ec = phase===2 ? (pTimer<45?'#fff':'#ccc') : (moving?(Math.sin(t*0.3)>0?'#fff':'#999'):'#bbb');
  ctx.shadowColor='#fff'; ctx.shadowBlur=phase===2&&pTimer<45?12:4;
  [[19,-4],[24,-4],[19,3],[24,3]].forEach(([ex,ey])=>{ ctx.fillStyle=ec; ctx.beginPath(); ctx.arc(ex,ey,2,0,Math.PI*2); ctx.fill(); });
  ctx.shadowBlur=0;

  // Antennae
  ctx.strokeStyle='#888'; ctx.lineWidth=1.2;
  let aw=Math.sin(t*0.1)*5;
  ctx.beginPath(); ctx.moveTo(27,-7); ctx.quadraticCurveTo(34,-18+aw,38,-22+aw); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(27,-3); ctx.quadraticCurveTo(36,-6+aw*0.5,40,-7+aw*0.7); ctx.stroke();
  ctx.fillStyle='#ccc'; ctx.shadowColor='#fff'; ctx.shadowBlur=4;
  ctx.beginPath(); ctx.arc(38,-22+aw,2.5,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(40,-7+aw*0.7,1.8,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;

  // Scan beam in phase 0
  if(phase===0){
    let sa=t*0.04;
    ctx.globalAlpha=0.2+0.1*Math.sin(t*0.1); ctx.strokeStyle='#ccc'; ctx.lineWidth=0.8; ctx.setLineDash([4,4]);
    for(let b=-1;b<=1;b++){ ctx.beginPath(); ctx.moveTo(32,0); ctx.lineTo(32+Math.cos(sa+b*0.25)*90,Math.sin(sa+b*0.25)*90); ctx.stroke(); }
    ctx.setLineDash([]); ctx.globalAlpha=1;
  }

  ctx.restore();

  // "ALONGSIDE HOSTILE" label in phase 2
  if(phase===2&&pTimer<44){
    ctx.save(); ctx.shadowColor='#fff'; ctx.shadowBlur=6;
    ctx.font='bold 8px Courier New'; ctx.fillStyle='#ddd'; ctx.textAlign='center';
    ctx.fillText('ALONGSIDE HOSTILE',rx,ry-46);
    ctx.restore();
  }
  // "MISSION COMPLETE"
  if(phase===3&&pFrac()>0.88){
    ctx.save(); ctx.shadowColor='#fff'; ctx.shadowBlur=8;
    ctx.font='bold 9px Courier New'; ctx.fillStyle='#eee'; ctx.textAlign='center';
    ctx.fillText('MISSION COMPLETE',rx,ry-46);
    ctx.restore();
  }

  ctx.font='6px Courier New'; ctx.fillStyle='#666'; ctx.textAlign='center'; ctx.fillText('CENTAUR-BOT',rx,ry+28);
}

// ─────────────────────────────────────────────
// SCAN RINGS
// ─────────────────────────────────────────────
function updateDrawScanRings(){
  if(phase===0&&t%25===0) scanRings.push({x:botX,y:botY-8,r:0,life:1});
  scanRings=scanRings.filter(s=>s.life>0);
  scanRings.forEach(s=>{
    s.r+=2; s.life-=0.03;
    ctx.globalAlpha=s.life*0.4; ctx.strokeStyle='#aaa'; ctx.lineWidth=1; ctx.setLineDash([3,6]);
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]); ctx.globalAlpha=1;
  });
}

// ─────────────────────────────────────────────
// DECISION BUBBLE
// ─────────────────────────────────────────────
function drawDecisionBubble(){
  if(phase!==0) return;
  let alpha=clamp(pTimer/35,0,1); if(alpha<=0) return;
  ctx.globalAlpha=alpha;
  let bx=botX+28,by=botY-115,bw=158,bh=75;
  ctx.fillStyle='#0d0d0d'; ctx.strokeStyle='#888'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.roundRect(bx,by,bw,bh,4); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(bx+8,by+bh); ctx.lineTo(bx,by+bh+10); ctx.lineTo(bx+18,by+bh); ctx.fill();
  [{l:'THREAT',v:0.88},{l:'CONFIDENCE',v:0.93},{l:'PATH CLEAR',v:0.74}].forEach((row,i)=>{
    let ry2=by+16+i*20; ctx.font='7px Courier New';
    ctx.fillStyle='#555'; ctx.textAlign='left'; ctx.fillText(row.l,bx+6,ry2);
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(bx+80,ry2-8,68,8);
    let v=row.v*(0.9+Math.random()*0.1);
    ctx.fillStyle='#aaa'; ctx.fillRect(bx+80,ry2-8,68*v,8);
    ctx.fillStyle='#888'; ctx.textAlign='right'; ctx.fillText((v*100).toFixed(0)+'%',bx+bw-3,ry2-1);
  });
  ctx.font='bold 7px Courier New'; ctx.fillStyle='#ccc'; ctx.textAlign='left';
  ctx.fillText('→ APPROACH & NEUTRALISE',bx+6,by+bh-8);
  ctx.globalAlpha=1; ctx.textAlign='center';
}

// ─────────────────────────────────────────────
// THREAT BRACKETS
// ─────────────────────────────────────────────
function drawBrackets(cx,cy,w,h,label,alpha){
  if(alpha<=0) return; ctx.globalAlpha=alpha;
  let cs=8,l=cx-w/2,r2=cx+w/2,top=cy-h;
  [[l,top],[r2,top],[l,cy],[r2,cy]].forEach(([bx,by],i)=>{
    let sx=i%2===0?1:-1,sy=i<2?1:-1;
    ctx.strokeStyle='#bbb'; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(bx,by+sy*cs); ctx.lineTo(bx,by); ctx.lineTo(bx+sx*cs,by); ctx.stroke();
  });
  ctx.font='7px Courier New'; ctx.fillStyle='#999'; ctx.textAlign='center'; ctx.fillText(label,cx,top-4);
  ctx.globalAlpha=1;
}

// ─────────────────────────────────────────────
// HUD
// ─────────────────────────────────────────────
function updateHUD(){
  const T=['MED','HIGH','CRITICAL','BOOM!','CLEAR','—'];
  const S=['SCANNING','APPROACH','ENCOUNTER','NEUTRALISED','CLEAR RUN','DONE'];
  document.getElementById('h1').textContent='THREAT: '+T[phase];
  document.getElementById('h2').textContent='PATH: '+(overallProgress()*100).toFixed(0)+'%';
  document.getElementById('h3').textContent='STATE: '+S[phase];
  document.getElementById('phase-label').textContent='[ '+(
    phase===0?'NEURO-FUZZY SCAN — PLOTTING INTERCEPT PATH':
    phase===1?'APPROACHING HOSTILE — UNDER FIRE — NAVIGATING':
    phase===2?'ALONGSIDE HOSTILE — BARREL DETONATING':
    phase===3?'HOSTILE K.I.A. — CLEAR PATH TO EXIT':
    phase===4?'MISSION COMPLETE — RESETTING...':''
  )+' ]';
}

// ─────────────────────────────────────────────
// MAIN LOOP
// ─────────────────────────────────────────────
function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#0d0d0d'; ctx.fillRect(0,0,W,H);

  drawFloor();
  drawBulletHoles();
  drawPaths();
  drawRoom();

  if(expl) drawExplosion();

  drawBarrel();
  drawBot();
  updateDrawScanRings();
  drawStickman();
  drawBullets();

  // Brackets — fade out on death
  let ba=stkDead?clamp(1-stkAngle/(Math.PI/2),0,1):1;
  let bba=barrelGone?0:1;
  drawBrackets(tc(1,5).x+5,tc(1,5).y-12,36,52,'FLAMMABLE',bba);
  drawBrackets(tc(6,6).x,tc(6,6).y-12,40,76,'HOSTILE',ba);

  drawDecisionBubble();

  // Corner labels
  ctx.font='7px Courier New'; ctx.fillStyle='#2a2a2a';
  ctx.textAlign='left'; ctx.fillText('(0,0)',isoX(0,0)+2,isoY(0,0)-2);
  ctx.textAlign='right'; ctx.fillText(`(${COLS},${ROWS})`,isoX(COLS,ROWS)-2,isoY(COLS,ROWS)+20);

  updateHUD();
}

function loop(){ t++; updatePhase(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
